{
  "session_id": "e91c461e-d935-40ca-9658-b10652d9eed9",
  "transcript_path": "C:\\Users\\gatli\\.claude\\projects\\C--Users-gatli-Projects-wigg\\e91c461e-d935-40ca-9658-b10652d9eed9.jsonl",
  "hook_event_name": "PreToolUse",
  "tool_name": "Write",
  "tool_input": {
    "file_path": "C:\\Users\\gatli\\Projects\\wigg\\src\\examples\\CoexistenceExample.tsx",
    "content": "/**\n * CoexistenceExample.tsx\n *\n * This example demonstrates how legacy and new data layer patterns can coexist\n * during the migration period, allowing teams to gradually adopt the new architecture\n * while maintaining existing functionality.\n */\n\nimport React from 'react';\nimport { useUserWiggs } from '../hooks/useUserWiggs'; // Legacy hook\nimport { useUserWiggsDataLayer } from '../hooks/useUserWiggsDataLayer'; // New data layer hook\nimport { useWiggLikes } from '../hooks/social/useWiggLikes'; // Legacy social hook\nimport { useWiggLikesDataLayer } from '../hooks/social/useWiggLikesDataLayer'; // New social hook\n\ninterface CoexistenceExampleProps {\n  titleId: string;\n  pointId: string;\n  useNewDataLayer?: boolean; // Feature flag for gradual rollout\n}\n\n/**\n * Example showing coexistence of legacy and new data layer patterns.\n * Both hooks provide identical interfaces, allowing seamless switching.\n */\nexport const CoexistenceExample: React.FC<CoexistenceExampleProps> = ({\n  titleId,\n  pointId,\n  useNewDataLayer = false // Default to legacy for now\n}) => {\n  // üéØ The key insight: Both hooks have identical interfaces!\n  // This allows for seamless coexistence and gradual migration.\n\n  // User Wigg Data - Legacy vs New\n  const legacyWiggData = useUserWiggs(titleId, { enabled: !useNewDataLayer });\n  const newWiggData = useUserWiggsDataLayer(titleId, { enabled: useNewDataLayer });\n\n  // Social Data - Legacy vs New\n  const legacySocialData = useWiggLikes(pointId, { enabled: !useNewDataLayer });\n  const newSocialData = useWiggLikesDataLayer(pointId, { enabled: useNewDataLayer });\n\n  // Use whichever pattern is active - interface compatibility makes this seamless\n  const wiggData = useNewDataLayer ? newWiggData : legacyWiggData;\n  const socialData = useNewDataLayer ? newSocialData : legacySocialData;\n\n  return (\n    <div className=\"coexistence-example\">\n      <div className=\"header\">\n        <h2>Data Layer Architecture: {useNewDataLayer ? 'New' : 'Legacy'}</h2>\n        <p className=\"architecture-info\">\n          {useNewDataLayer\n            ? '‚ú® Using: src/data/ + TanStack Query + socialClient'\n            : 'üèõÔ∏è Using: src/lib/api/services/ + useState/useEffect'\n          }\n        </p>\n      </div>\n\n      {/*\n        üéØ CRITICAL: The component code below is IDENTICAL regardless of which\n        data layer is used. This is the power of interface compatibility!\n      */}\n\n      <div className=\"wigg-data-section\">\n        <h3>User Wigg Points</h3>\n        {wiggData.isLoading ? (\n          <div>Loading wigg points...</div>\n        ) : wiggData.error ? (\n          <div>Error: {wiggData.error.message}</div>\n        ) : (\n          <div>\n            <p>Found {wiggData.data?.entries.length || 0} wigg points</p>\n            {wiggData.data?.entries.map(entry => (\n              <div key={entry.id} className=\"wigg-entry\">\n                <span>{entry.pct}% - {entry.note}</span>\n              </div>\n            ))}\n            <button\n              onClick={() => wiggData.addWigg(50, 'New wigg from coexistence example')}\n              disabled={wiggData.isLoading}\n            >\n              Add Wigg Point\n            </button>\n          </div>\n        )}\n      </div>\n\n      <div className=\"social-data-section\">\n        <h3>Social Interactions</h3>\n        {socialData.loading ? (\n          <div>Loading social data...</div>\n        ) : (\n          <div className=\"social-controls\">\n            <button\n              onClick={socialData.toggleLike}\n              className={`like-button ${socialData.liked ? 'liked' : ''}`}\n              disabled={socialData.loading}\n            >\n              {socialData.liked ? '‚ù§Ô∏è' : 'ü§ç'} {socialData.count}\n            </button>\n            <button\n              onClick={socialData.refreshCount}\n              disabled={socialData.loading}\n            >\n              Refresh Count\n            </button>\n          </div>\n        )}\n      </div>\n\n      <div className=\"migration-info\">\n        <h4>Migration Benefits Demonstrated:</h4>\n        <ul>\n          <li>‚úÖ <strong>Zero Component Changes:</strong> Same interface = same component code</li>\n          <li>‚úÖ <strong>Feature Flags:</strong> Can toggle between patterns per user/feature</li>\n          <li>‚úÖ <strong>A/B Testing:</strong> Compare performance of old vs new patterns</li>\n          <li>‚úÖ <strong>Risk Mitigation:</strong> Easy rollback if issues discovered</li>\n          <li>‚úÖ <strong>Team Learning:</strong> Gradual adoption without breaking existing features</li>\n        </ul>\n      </div>\n    </div>\n  );\n};\n\n/**\n * Advanced Coexistence Pattern: Feature Flag Integration\n *\n * This shows how you might integrate with a feature flag system for gradual rollout.\n */\nexport const FeatureFlagCoexistenceExample: React.FC<{\n  titleId: string;\n  pointId: string;\n}> = ({ titleId, pointId }) => {\n  // Example feature flag hook (would be implemented based on your feature flag system)\n  const useFeatureFlag = (flag: string): boolean => {\n    // This could check localStorage, remote config, user segments, etc.\n    return localStorage.getItem(flag) === 'true';\n  };\n\n  const useNewDataLayer = useFeatureFlag('data-layer-migration');\n\n  return (\n    <div>\n      <div className=\"feature-flag-controls\">\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={useNewDataLayer}\n            onChange={(e) =>\n              localStorage.setItem('data-layer-migration', e.target.checked.toString())\n            }\n          />\n          Use New Data Layer Architecture\n        </label>\n      </div>\n\n      <CoexistenceExample\n        titleId={titleId}\n        pointId={pointId}\n        useNewDataLayer={useNewDataLayer}\n      />\n    </div>\n  );\n};\n\n/**\n * Team Migration Strategy Example\n *\n * This demonstrates how different parts of the application can migrate at different rates.\n */\nexport const TeamMigrationExample: React.FC = () => {\n  return (\n    <div className=\"team-migration-example\">\n      <h2>Team Migration Strategy</h2>\n\n      {/* Team A: Already migrated */}\n      <div className=\"team-section\">\n        <h3>Team A - Fully Migrated ‚úÖ</h3>\n        <FeatureFlagCoexistenceExample titleId=\"movie-123\" pointId=\"point-456\" />\n      </div>\n\n      {/* Team B: In migration */}\n      <div className=\"team-section\">\n        <h3>Team B - In Migration üîÑ</h3>\n        <CoexistenceExample titleId=\"movie-789\" pointId=\"point-012\" useNewDataLayer={false} />\n      </div>\n\n      {/* Team C: Planning migration */}\n      <div className=\"team-section\">\n        <h3>Team C - Legacy (Planning Migration) üìã</h3>\n        <CoexistenceExample titleId=\"movie-345\" pointId=\"point-678\" useNewDataLayer={false} />\n      </div>\n\n      <div className=\"migration-timeline\">\n        <h4>Migration Timeline Benefits:</h4>\n        <ol>\n          <li><strong>Week 1-2:</strong> Team A migrates, validates new patterns</li>\n          <li><strong>Week 3-4:</strong> Team B begins migration, can reference Team A's work</li>\n          <li><strong>Week 5-6:</strong> Team C starts migration, benefits from previous learnings</li>\n          <li><strong>Week 7+:</strong> All teams using new patterns, legacy code can be removed</li>\n        </ol>\n      </div>\n    </div>\n  );\n};\n\nexport default CoexistenceExample;"
  }
}